import PostgrestFilterBuilder from './PostgrestFilterBuilder';
import { GetResult } from './select-query-parser';
import { Fetch, GenericTable, GenericView } from './types';
export default class PostgrestQueryBuilder<Relation extends GenericTable | GenericView> {
    url: URL;
    headers: Record<string, string>;
    schema?: string;
    signal?: AbortSignal;
    fetch?: Fetch;
    constructor(url: URL, { headers, schema, fetch, }: {
        headers?: Record<string, string>;
        schema?: string;
        fetch?: Fetch;
    });
    /**
     * Performs vertical filtering with SELECT.
     *
     * @param columns  The columns to retrieve, separated by commas.
     */
    select<Query extends string = '*', Result = GetResult<Relation['Row'], Query extends '*' ? '*' : Query>>(columns?: Query, { head, count, }?: {
        /** When set to true, select will void data. */
        head?: boolean;
        /** Count algorithm to use to count rows in a table. */
        count?: 'exact' | 'planned' | 'estimated';
    }): PostgrestFilterBuilder<Relation['Row'], Result>;
    /**
     * Performs an INSERT into the table.
     *
     * @param values    The values to insert.
     */
    insert<Row extends Relation extends {
        Insert: unknown;
    } ? Relation['Insert'] : never>(values: Row | Row[], { count, }?: {
        /** Count algorithm to use to count rows in a table. */
        count?: 'exact' | 'planned' | 'estimated';
    }): PostgrestFilterBuilder<Relation['Row'], undefined>;
    /**
     * Performs an UPSERT into the table.
     *
     * @param values  The values to insert.
     */
    upsert<Row extends Relation extends {
        Insert: unknown;
    } ? Relation['Insert'] : never>(values: Row | Row[], { onConflict, count, ignoreDuplicates, }?: {
        /** By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint. */
        onConflict?: string;
        /** Count algorithm to use to count rows in a table. */
        count?: 'exact' | 'planned' | 'estimated';
        /** Specifies if duplicate rows should be ignored and not inserted. */
        ignoreDuplicates?: boolean;
    }): PostgrestFilterBuilder<Relation['Row'], undefined>;
    /**
     * Performs an UPDATE on the table.
     *
     * @param values  The values to update.
     */
    update<Row extends Relation extends {
        Update: unknown;
    } ? Relation['Update'] : never>(values: Row, { count, }?: {
        /** Count algorithm to use to count rows in a table. */
        count?: 'exact' | 'planned' | 'estimated';
    }): PostgrestFilterBuilder<Relation['Row'], undefined>;
    /**
     * Performs a DELETE on the table.
     */
    delete({ count, }?: {
        /** Count algorithm to use to count rows in a table. */
        count?: 'exact' | 'planned' | 'estimated';
    }): PostgrestFilterBuilder<Relation['Row'], undefined>;
}
//# sourceMappingURL=PostgrestQueryBuilder.d.ts.map